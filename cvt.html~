<html>
    <head>
		<title>d3.js</title>
		
        <script type="text/javascript" src="d3/d3.v2.js">
		</script>
		
		<link href="./colorbrewer.css" rel="stylesheet" type="text/css">
		<link href="./voronoi.css" rel="stylesheet" type="text/css">
		
	</head>

	<body>
	<h1 id="voronoi_diagram">Voronoi Tesselation</h1>
	
	<div class="gallery" id="chart"></div>

		
	<script type="text/javascript">
	var width = 960,
    height = 500,
	n = 500;

	var vertices = [], verticesNew = [];
	var voronoi, voronoiNew=[];
	var svg= d3.select("#chart").append("svg");

	generate();
	draw();

	function generate() {
		vertices = d3.range(n).map(function(d) {
		  return [Math.random() * width, Math.random() * height];
		});
		
		voronoi = d3.geom.voronoi(vertices);
		
		for (var i = 0; i < voronoi.length; i++) {
			voronoiNew[i] = [];
			for (var j = 0; j < voronoi[i].length; j++) {
				voronoiNew[i][j] = voronoi[i][j].slice(0);
			}
		}
		
		for (var i = 0; i < vertices.length; i++) {
			verticesNew[i] = vertices[i].slice(0);
		}
	}
	
	function toodles(a,b,c) {
		return a
	}
	
	function draw() {
		svg.selectAll("circle").remove();
		svg.selectAll("path").remove();
	
		svg.attr("width", width)
			.attr("height", height)
			.attr("class", "PiYG")
			.on("mouseover", update);

		svg.selectAll("path")
			.data(voronoiNew)
		  .enter().append("path")
			.attr("class", function(d, i) { return i ? "q" + (i % 9) + "-9" : null; })
			.attr("d", function(d) { return "M" + d.join("L") + "Z"; });

		svg.selectAll("circle")
			.data(verticesNew.slice(1))
		  .enter().append("circle")
			.attr("transform", function(d) { return "translate(" + d + ")"; })
			.attr("r", 2);
			
		function update() {
		//	if (is_run) {
		//		is_run = false;
		//		clearInterval(animation);
		//	}
		
			verticesNew[0] = d3.mouse(this);
			voronoiNew = d3.geom.voronoi(verticesNew);
			svg.selectAll("path")
				.data(voronoiNew
				.map(function(d) { return "M" + d.join("L") + "Z"; }))
				.filter(function(d) { return this.getAttribute("d") != d; })
				.attr("d", function(d) { return d; });
		}
	}
	


	</script>
	
	<button id="centroid_step">One Centroid Step</button>
	<button id="centroid_anim">Start/Stop Centroid Animation</button>
	<button id="generate">Generate New Points</button>
	<button id="reset">Undo Centroidal</button>

	<div id="fun">
	<p>In a Voronoi tesselation, each region corresponds to the set of points closest to the a distinguished point 
	(circle) inside the region. The initial set of distinguished points is chosen at random. </p>
	
	<p>Colors by <a href="http://colorbrewer.org/">Cynthia Brewer</a>. Voronoi design commonly attributed to 
	<a href="http://en.wikipedia.org/wiki/Lejeune_Dirichlet">Lejeune Dirichlet</a> and 
	<a href="http://en.wikipedia.org/wiki/Georgy_Voronoy">Georgy Voronoy</a>. Voronoi algorithm by 
	<a href="http://ect.bell-labs.com/who/sjf/">Steven Fortune</a>; implementation based on work 
	by <a href="http://blog.thejit.org/2010/02/12/voronoi-tessellation/">Nicolas Garcia Belmonte</a>. 
	Mouseover interaction inspired by <a href="http://www.raymondhill.net/blog/?p=9">Raymond Hill</a>.</p>
	
	<p>Centroidal Voronoi features implemented by Dmitry Shemetov. Lloyd's algorithm animation, other 
	algorithms and all that.</p>
	</div>
	
	<script type="text/javascript">
	// Variables
	var C = [], 
		normalized = [];
	var area,
		sum_x,
		sum_y,
		region;

		
	// Button behavior
	// Generate
	d3.select("#generate").on("click", function () { 
		generate();
		draw();
	});
	
	// Centroid Step
	d3.select("#centroid_step").on("click", function () {
		clipVoronoi();
		centroid();
		centroid_update();
	});
	
	var animation;
	var is_run = false;
	
	// Centroid Animation
	d3.select("#centroid_anim").on("click", function () {		
		if (!is_run){
			is_run = true;
			animation = window.setInterval(function () { 
				clipVoronoi(); 
				centroid(); 
				centroid_update(); },25);
		}
		else {
			is_run = false;
			clearInterval(animation);
		}
		
		/*
		do {
			clipVoronoi();
			centroid();
			setTimeout(50);
			a = centroid_update();
		} while (a > 50);*/
	});
	
	// Stop Button
	d3.select("#centroid_stop").on("click", function () {
		clearInterval(intervalID);
	});
	
	d3.select("#reset").on("click",function () {
		for (var i = 0; i < voronoi.length; i++) {
			voronoiNew[i] = [];
			for (var j = 0; j < voronoi[i].length; j++) {
				voronoiNew[i][j] = voronoi[i][j].slice(0);
			}
		}
		
		for (var i = 0; i < vertices.length; i++) {
			verticesNew[i] = vertices[i].slice(0);
		}
		draw();
	});

	
	// Utility functions
	function inBoundary(x,y) {	
		if (x < 0 || y < 0 || y > height || x > width)
			return false;
		return true;
	}
	
	function doesIntersect(n0, n1, n2, n3) {
		var denom = (n3.y - n2.y) * (n1.x - n0.x) - 
					(n3.x - n2.x) * (n1.y - n0.y);

		// Parallel
		if (denom === 0) {
			return false;
		}

		var ua = ((n3.x - n2.x) * (n0.y - n2.y) - 
				  (n3.y - n2.y) * (n0.x - n2.x)) / denom,
			ub = ((n1.x - n0.x) * (n0.y - n2.y) - 
				  (n1.y - n0.y) * (n0.x - n2.x)) / denom,
			x = Math.round(n0.x + ua * (n1.x - n0.x)),
			y = Math.round(n0.y + ua * (n1.y - n0.y));
			result = new Node(x, y, "y");

		if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
			// Collision detected
			return result;
		} else {
			// No collision
			return false;
		}
	};
	
	function Node(x,y,intersection,entry,exit) {
		this.x = x;
		this.y = y;
		this.intersection = intersection ? intersection : false;
		this.entry = entry ? entry : false;
		this.exit = exit ? exit : false;
		
		this.updateEntry = function() {
			this.entry = true;
		}
		
		this.updateExit = function() {
			this.exit = true;
		}
		
		this.updateIntersection = function(side) {
			this.intersection = side;
		}
	}
	
	function toNodes(array) {
		var nodeArray = [];
		for (var i=0; i < array.length; i++) {
			nodeArray.push(new Node(array[i][0],
									array[i][1],
									false,
									false,
									false));
		}
		
		return nodeArray;
	}
	
	function distance(n0,n1) {
		return Math.sqrt((n0.x - n1.x) * (n0.x - n1.x) + 
						 (n0.y - n1.y) * (n0.y - n1.y));
	}
	
	function polyclip (subject,clip) {
		var nodesPoly = toNodes(subject);
		var nodesRect = toNodes(clip);
		var newPoly = [];
		var clipped = [];
		var j;
	
		for (var i = 0; i < nodesPoly.length; i++)
		{
			// in boundary
			if (inBoundary(nodesPoly[i].x, nodesPoly[i].y)) {
				newPoly.push(nodesPoly[i]);
			
				// exiting
				if (!inBoundary(nodesPoly[(i+1) % nodesPoly.length].x, 
								nodesPoly[(i+1) % nodesPoly.length].y)) {
								
					j = 0;
					
					do {
						result = doesIntersect(nodesPoly[i], 
											   nodesPoly[(i+1) % nodesPoly.length],
											   nodesRect[j], 
											   nodesRect[(j+1) % nodesRect.length]);
						j++;
					}
					while (j < nodesRect.length && !result);
					
					result.updateExit();
					if (result.x == 0) {
						result.updateIntersection("left");
					}
					else if (result.x == width) {
						result.updateIntersection("right");
					}
					else if (result.y == 0) {
						result.updateIntersection("top");
					}
					else {
						result.updateIntersection("bottom");
					}
					newPoly.push(result);
				}
			}
			// out of boundary
			else {
				//entering
				if (inBoundary(nodesPoly[(i+1) % nodesPoly.length].x, 
							   nodesPoly[(i+1) % nodesPoly.length].y)) {
								
					j = 0;
					
					do {
						result = doesIntersect(nodesPoly[i], 
											   nodesPoly[(i+1) % nodesPoly.length],
											   nodesRect[j], 
											   nodesRect[(j+1) % nodesRect.length]);
						j++;
					}
					while (j < nodesRect.length && !result);
					
					result.updateEntry();
					if (result.x == 0) {
						result.updateIntersection("left");
					}
					else if (result.x == width) {
						result.updateIntersection("right");
					}
					else if (result.y == 0) {
						result.updateIntersection("top");
					}
					else {
						result.updateIntersection("bottom");
					}
					newPoly.push(result);
				}
				// degenerate case - no interior points
				else {
					var a = [], k = 0;
					for (var j = 0; j < nodesRect.length; j++) {
						result = doesIntersect(nodesPoly[i], 
											   nodesPoly[(i+1) % nodesPoly.length],
											   nodesRect[j], 
											   nodesRect[(j+1) % nodesRect.length]);
						if (result) {
							if (result.x == 0) {
								result.updateIntersection("left");
							}
							else if (result.x == width) {
								result.updateIntersection("right");
							}
							else if (result.y == 0) {
								result.updateIntersection("top");
							}
							else {
								result.updateIntersection("bottom");
							}
							a[k] = result;
							k++;
						}
					}
					if (a.length > 0) {
						if (distance(nodesPoly[i],a[0]) < distance(nodesPoly[i],a[1])) {
							a[0].updateEntry();
							newPoly.push(a[0]);
							a[1].updateExit();
							newPoly.push(a[1]);
						}
						else {
							a[1].updateEntry();
							newPoly.push(a[1]);
							a[0].updateExit();
							newPoly.push(a[0]);
						}
					}
				}
			}
		}
		
		var i = 0;
		var j;
		while (i < newPoly.length) {
			if (newPoly[i].entry) {
				if (i - 1 < 0) {
					j = newPoly.length - 1;
				}
				else {
					j = i - 1;
				}
			
				if (newPoly[i].intersection != newPoly[j].intersection) {
					if (newPoly[i].intersection == "top") {
						if (newPoly[j].intersection == "left") {
							clipped.push([0,height]);
							clipped.push([width,height]);
							clipped.push([width,0]);
						}
						else if (newPoly[j].intersection == "bottom") {
							clipped.push([width,height]);
							clipped.push([width,0]);
						}
						else if (newPoly[j].intersection == "right") {
							clipped.push([width,0]);
						}
					}
					else if (newPoly[i].intersection == "left") {
						if (newPoly[j].intersection == "top") {
							clipped.push([0,0]);
						}
						else if (newPoly[j].intersection == "bottom") {
							clipped.push([width,height]);
							clipped.push([width,0]);
							clipped.push([0,0]);
						}
						else if (newPoly[j].intersection == "right") {
							clipped.push([width,0]);
							clipped.push([0,0]);
						}
					}
					else if (newPoly[i].intersection == "bottom") {
						if (newPoly[j].intersection == "top") {
							clipped.push([0,0]);
							clipped.push([0,height]);
						}
						else if (newPoly[j].intersection == "left") {
							clipped.push([0,height]);
						}
						else if (newPoly[j].intersection == "right") {
							clipped.push([width,0]);
							clipped.push([0,0]);
							clipped.push([0,height]);
						}
					}
					else if (newPoly[i].intersection == "right") {
						if (newPoly[j].intersection == "top") {
							clipped.push([0,0]);
							clipped.push([0,height]);
							clipped.push([width,height]);
						}
						else if (newPoly[j].intersection == "left") {
							clipped.push([0,height]);
							clipped.push([width,height]);
						}
						else if (newPoly[j].intersection == "bottom") {
							clipped.push([width,height]);
						}
					}
				}
				
				clipped.push([newPoly[i].x,newPoly[i].y]);
			}
			else {
				clipped.push([newPoly[i].x,newPoly[i].y])
			}
			i++;
		}
		
		return clipped;
	}	
	
	// Polygon clipping
	function clipVoronoi () {
		var region;
		var rectangle =  [[0,0],[0,height],[width,height],[width,0]];
		var temp1;
		var j;
		
		// loop through each region and clip each polygon
		// to the rectangle
		for (var i = 0; i < n; i++) {
			j = 0;
			while (j < voronoiNew[i].length && inBoundary(voronoiNew[i][j][0],voronoiNew[i][j][1])) {
				j++;
			}
			if (j < voronoiNew[i].length && !inBoundary(voronoiNew[i][j][0],voronoiNew[i][j][1])) {
				temp1 = polyclip(voronoiNew[i],rectangle);
				voronoiNew[i] = temp1;
			}
		}
	}

	// Centroid
	// Method 1 - Centroid of a polygon, formula
	function centroid () {
		C = [];
		
		for (var i = 0; i < n; i++) {
			sum_x = 0,
			sum_y = 0,
			sum_area = 0;

			for (var j = 0; j < voronoiNew[i].length; j++) {
				region = voronoiNew[i][j][0] * 
						 voronoiNew[i][(j+1) % voronoiNew[i].length][1] - 
						 voronoiNew[i][(j+1) % voronoiNew[i].length][0] * 
						 voronoiNew[i][j][1];

				sum_x += (voronoiNew[i][j][0] + 
						  voronoiNew[i][(j+1) % voronoiNew[i].length][0]) * 
						  region;
				sum_y += (voronoiNew[i][j][1] + 
						  voronoiNew[i][(j+1) % voronoiNew[i].length][1]) * 
						  region;
				sum_area += region;
			}

			C[i] = [];
			C[i][0] = sum_x/(3*sum_area);
			C[i][1] = sum_y/(3*sum_area);
		}
	}
	
	function centroid_update () {
		var r = 1;
		var motion = 0;
		var change;
		
		for (var i = 0; i < vertices.length; i++) {
			change = Math.sqrt( (C[i][0] - verticesNew[i][0]) * 
								(C[i][0] - verticesNew[i][0]) + 
								(C[i][1] - verticesNew[i][1]) * 
								(C[i][1] - verticesNew[i][1]) );
			
			motion += change;
		
			if (change > .01) {
				verticesNew[i][0] = C[i][0] * r + (1 - r) * verticesNew[i][0];
				verticesNew[i][1] = C[i][1] * r + (1 - r) * verticesNew[i][1];
			}
		}
		
		voronoiNew = d3.geom.voronoi(verticesNew);
		draw();
		
		return motion;
	}
	
	// Method 2 - Integration
	</script>
	</body>
</html>
